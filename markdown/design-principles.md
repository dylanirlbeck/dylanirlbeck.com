# Design principles for dylanirlbeck.com

As I’ve progressed throughout my brief career, one thing I’ve learned is the value of understanding the inner-workings of the tools I use every day. I’m currently a software engineer, so these tools include: [Git](https://en.wikipedia.org/wiki/Git), a version control system; [Neovim](https://neovim.io/), a terminal-based text editor; [Ruby](https://www.ruby-lang.org/en/), a programming language, and [Ruby on Rails](https://rubyonrails.org/) (or Rails, for short), a web application framework; and many other tools that are less prominent as of writing.

These tools are designed to be _used_ by engineers like myself to, most directly, build software “better.” Git makes it easier to collaborate with other developers; Neovim comes replete with quick commands for editing source code; Ruby and Rails provide useful abstractions over machine code and web machinery, respectively. But these tools’ benefits to me as an engineer are limited, in my view, by my understanding of how they work at a deeper level. For example, by understanding how Rails’ [database query interface](https://guides.rubyonrails.org/active_record_querying.html) works under the hood, I can make better decisions as to when to write raw SQL in application code.

But mere “understanding” of a tool only gets you so far: there will always be more documentation to read, more blog posts to peruse, new source code to pore over. In my view, the ideal way for me to truly understand a tool — or any system, for that matter — is to build it myself. In most cases this is infeasible, however, both due to time and knowledge constraints. I accept this reality; I continue building software with a necessarily-incomplete understanding of my tools.

## Building over understanding

When it comes to building my personal website, however, I’ve made a different decision: I want to build it from pseudo-scratch. (I want to minimize the use of platforms, libraries, design systems. And absolutely _no_ static site generators — those things are inscrutable.)

Why focus my efforts on building a website, rather than the countless other tools I use every day? [The Web](https://en.wikipedia.org/wiki/World_Wide_Web) strikes me as the most influential digital system of the past few decades. The work I do every day is on a web application; and the solutions to many pressing problems, in my view, will reside on the web — as websites, web applications, or some other web-based technology that’s yet to hit the mainstream.

As I see it, the only way I’ll gain a deeper understanding of this fundamental technology is by building _directly_ on top of its most fundamental components: HTML, CSS, and JavaScript.

## Design principles

For posterity, I want to define some design principles that I aim to hold myself to as I build. (Unfortunately, and as evidenced by this post’s existence on my website, these principles are coming a tad late — in retrospect, I would have written this post _before_ I wrote any code! Anyway...) Namely, I will:

- _Keep the site’s content readable, accessible, and navigable._ Especially when it comes to blog posts, I intend for my content to be readable by **everyone**, regardless of physical impairments. The site should be mobile-friendly and hyper-fast, though these are less important up-front. I’ll test my website’s overall performance via Netlify’s [Testmysite.io](http://Testmysite.io) tool. (As of this writing, my site scored a 99/100.)
- _Minimize the gap between the core web technologies and the system that supports my website._ I’ve already mentioned my distaste for [static site generators](https://www.cloudflare.com/learning/performance/static-site-generator/) (SSG): these systems try to be everything for everyone, and in the process provide an abstraction that is _many_ levels above the core elements of the Web. I plan to eschew technologies like SSGs and their cousins — web frameworks (like [React](https://reactjs.org/)) and CSS frameworks (such as [TailwindCSS](https://tailwindcss.com/)) — in the hope that I will always be able to reason about my system.
- _Build with transparency._ Ideally, anyone would be able to clone my process — the source code, build and deployment process, etc. — with confidence. To start, I’ll keep to this principle by (a) keeping my website code [open-source](https://github.com/dylanirlbeck/dylanirlbeck.com), (b) including comprehensive code comments where relevant, and (c) publishing regularly about my process (and any noteworthy improvements I make).
- _Automate only when necessary_. For example, there are a number of [premature optimizations](https://softwareengineering.stackexchange.com/questions/80084/is-premature-optimization-really-the-root-of-all-evil) I could make right now vis-a-vis my HTML generation process: at present, I write Markdown locally, in [Notion](http://notion.so), and once it is done I generate HTML and edit it to make it suitable for publishing. There are micro-steps that I’m positive could be obviated with a little bit of software. That said, my blog probably has one reader, me, and so I’d be spending time automating when I _should_ be spending time writing better content. (Or finding new blog topics, reading, or simply staying away from my computer.) Put another way: I’ll make my blogging life easier when there is an obvious reason to. Similar logic applies to my decisions around website analytics, for instance.

You can follow along with me on [GitHub](https://github.com/dylanirlbeck/dylanirlbeck.com). I’m excited to see how this site — and my mental model of the World Wide Web — evolves.
